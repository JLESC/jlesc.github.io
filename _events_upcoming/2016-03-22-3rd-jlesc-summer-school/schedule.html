---
layout: page_event
title: 3rd JLESC Summer School
subtitle: Schedule
date: 2016-03-22
updated:
navbar: Events
event_location: ENS, Lyon, France
event_start: 2016-06-30
event_end: 2016-07-01
event_short_url:
event_url: 
wayback_url: 
kind: summer_school
institute: inria
permalink: /events/3rd-jlesc-summer-school/schedule/
page_type: event_subpage
---


<div id="schedule-accordion" role="tablist" aria-multiselectable="false">
  <div class="card">
    <div class="card-header" role="tab" id="day-zero-heading">
      <a data-toggle="collapse" data-parent="#schedule-accordion" href="#day-zero-content" aria-expanded="true" aria-controls="day-zero-content">
        <h4>Thursday, June 30th</h4>
      </a>
    </div>
    <div class="card-block collapse in" role="tabpanel" id="day-zero-content" aria-labelledby="day-zero-heading">
      <dl class="dl-horizontal">
        <dt>08:30</dt>
        <dd>
          <a class="abstract-btn" role="button"
             href="#abstract-d0-0830-robert" data-toggle="collapse"
             aria-expanded="false" aria-controls="abstract-d0-0830-robert">
            <i class="fa fa-fw fa-paragraph"></i>
          </a>
          <strong>Welcome and Introduction</strong><br />
          <small>{% person robert_y %}</small>
          <div class="abstract collapse" id="abstract-d0-0830-robert">
            Soon ...
          </div>
        </dd>

        <dt>08:45</dt>
        <dd>
          <a class="abstract-btn" role="button"
             href="#abstract-d0-0845-cappello" data-toggle="collapse"
             aria-expanded="false" aria-controls="abstract-d0-0845-cappello">
            <i class="fa fa-fw fa-paragraph"></i>
          </a>
          <strong>{% talk_label %} Improving the Trust in Results of Numerical Simulations and Scientific Data Analytics</strong><br />
          <small>{% person cappello_f %}</small>
          <div class="abstract collapse" id="abstract-d0-0845-cappello">
            Since the introduction of fault tolerance in HPC, fault tolerance
            papers have been dealing mainly with process crashes, network
            dysfunctions, and radiation induced bit flips. This orientation
            comes directly from the generic fault tolerance problems and
            solutions seen in distributed systems. Thus, the main objective
            has been to protect the execution - and that mostly in an
            application-agnostic way.

            Many real-life examples, however, demonstrate that application
            results can also be disrupted by hardware and software bugs.
            The risk of cyber attack is also taken seriously. Unfortunately,
            fault tolerance and resilience techniques currently used in HPC
            have not been designed for these types of disruptions; and in
            practice most fail to provide useful solutions.

            What matter is not only to protect HPC executions; it is also to
            protect the correctness of the results such executions produce.

            The scientific problem behind this statement is the trustworthiness
            of HPC application results. And to improve the trustworthiness, we
            must start from the results of the execution, as opposed to how the
            execution is implemented with processes and communications. The main
            objective is to avoid influential data corruptions related to the
            user-expected accuracy.

            This talk will review the notion of trust, the different types of
            disruptions leading to corruption of results, the ways that users
            build trust in application results, and the limitations of current
            techniques (fault tolerance/resilience, validation and verification,
            uncertainty quantification). We will present examples of results
            corruptions, some leading to catastrophic consequences, as well as
            an approach to improve result trustworthiness.
          </div>
        </dd>

        <dt>09:45</dt>
        <dd>
          <strong>Break</strong>
        </dd>

        <dt>10:00</dt>
        <dd>
          <a class="abstract-btn" role="button"
             href="#abstract-d0-1000-kramer" data-toggle="collapse"
             aria-expanded="false" aria-controls="abstract-d0-1000-kramer">
            <i class="fa fa-fw fa-paragraph"></i>
          </a>
          <strong>{% talk_label %} Expected and Unexpected Challenges to Extreme Scale Reliability</strong><br />
          <small>{% person kramer_b %}</small>
          <div class="abstract collapse" id="abstract-d0-1000-kramer">
            Extreme scale systems of today and tomorrow have on the order of a million
            to ten million processing elements, tens of millions of memory components
            and kilometers of interconnection cables. But these extreme scale systems,
            such as Blue Waters, are executing potentially billions of lines of
            software at any given instant in time.
            
            Studies of reliability traditionally focus on the many hardware
            components, their failure rates and the steps an application might take to
            mitigate such failures. While hardware failures are important to address,
            it is increasingly obvious many, some argue most, of system failures are
            software based.  Equally concerning is that recovery time (MTTR) from
            software errors takes longer and means the probability of double and
            triple faults having to be addressed simultaneously makes recovery and
            resiliency much more challenging.
            
            This talk will exam recent trends in reliability and performance analysis
            using most the data collected over more than two years of Blue Waters
            service.   It will draw insights as to the failure causes and possible
            solutions to make systems and applications more resilient. It will also
            offer comments on how to use today's insights into designing and
            implementing better systems and applications in the future.
          </div>
        </dd>

        <dt>11:00</dt>
        <dd>
          <a class="abstract-btn" role="button"
             href="#abstract-d0-1100-ropars" data-toggle="collapse"
             aria-expanded="false" aria-controls="abstract-d0-1100-ropars">
            <i class="fa fa-fw fa-paragraph"></i>
          </a>
          <strong>{% talk_label %} Checkpointing HPC applications</strong><br />
          <small>{% person ropars_t %}</small>
          <div class="abstract collapse" id="abstract-d0-1100-ropars">
            The goal of this talk is to give an overview of checkpointing
            techniques for HPC applications. It will present the main problems
            that need to be solved to ensure the successful execution of
            distributed applications despite crash failures. We will start by
            reviewing the basics of rollback-recovery techniques for
            message-passing applications (happened-before relation, consistent
            global state, etc.). We will then describe the main families of
            rollback-recovery protocols (checkpointing and message logging) and
            discuss their applicability in the HPC context.  Finally we will
            present the most recent advances (multi-level checkpointing,
            hierarchical protocols, etc.) in this area to cope with challenges
            raised by very large scale HPC systems.
          </div>
        </dd>

        <dt>12:00</dt>
        <dd>
          <strong>Lunch</strong>
        </dd>

        <dt>13:30</dt>
        <dd>
          <a class="abstract-btn" role="button"
             href="#abstract-d0-1330-benoit" data-toggle="collapse"
             aria-expanded="false" aria-controls="abstract-d0-1330-benoit">
            <i class="fa fa-fw fa-paragraph"></i>
          </a>
          <strong>{% talk_label %} Optimal checkpointing periods with fail-stop and silent errors</strong><br />
          <small>{% person benoit_a %}</small>
          <div class="abstract collapse" id="abstract-d0-1330-benoit">
            In this talk, we introduce probabilistic models to determine
            the optimal checkpointing periods (Young approximation and Dalyâ€™s
            formula) when the platform is confronted to fail-stop errors, both in
            the coordinated protocol and in the hierarchical one. Also, we extend
            these classical results to in-memory checkpointing, and discuss the
            impact of prediction and replication. Finally, we tackle silent errors
            by proposing models to deal with both fail-stop and silent errors, and
            we derive the optimal checkpointing periods in realistic frameworks. 
          </div>
        </dd>

        <dt>14:30</dt>
        <dd>
          <strong>Break</strong>
        </dd>

        <dt>14:45</dt>
        <dd>
          <a class="abstract-btn" role="button"
             href="#abstract-d0-1445-cavelan" data-toggle="collapse"
             aria-expanded="false" aria-controls="abstract-d0-1445-cavelan">
            <i class="fa fa-fw fa-paragraph"></i>
          </a>
          <strong>{% handson_label %} Mathematical Exercises on Daly and Extensions</strong><br />
          <small>{% person cavelan_a %}, {% person sun_h %}</small>
          <div class="abstract collapse" id="abstract-d0-1445-cavelan">
            In this talk, we will demonstrate the mathematical derivations of the classic Young/Daly formula on the optimal checkpointing interval for fail-stop errors.
            Also, we will introduce verification mechanisms (partial or guaranteed) to cope with silent errors, as well as multi-level checkpointing protocols for dealing with both error sources. Finally, we will show how to extend the results when also condisering the optimization of energy-consumption.
          </div>
        </dd>

        <dt>17:00</dt>
        <dd>
          <strong>End of Day 1</strong>
        </dd>
      </dl>
    </div>
  </div>


  <div class="card">
    <div class="card-header" role="tab" id="day-one-heading">
      <a data-toggle="collapse" data-parent="#schedule-accordion" href="#day-one-content" aria-expanded="true" aria-controls="day-one-content">
        <h4>Friday, July 1st</h4>
      </a>
    </div>
    <div class="card-block collapse in" role="tabpanel" id="day-one-content" aria-labelledby="day-one-heading">
      <dl class="dl-horizontal">
        <dt>08:45</dt>
        <dd>
          <a class="abstract-btn" role="button"
             href="#abstract-d1-0845-casas" data-toggle="collapse"
             aria-expanded="false" aria-controls="abstract-d1-0845-casas">
            <i class="fa fa-fw fa-paragraph"></i>
          </a>
          <strong>{% talk_label %} Resilience for Task-Graph Scheduling: OMPSS</strong><br />
          <small>{% person casas_m %}</small>
          <div class="abstract collapse" id="abstract-d1-0845-casas">
            In this talk we will describe in detail the opportunities that
            task-based programming models offer in terms of resilience. We will show
            how tasking enables asynchronous checkpoint/restart mechanisms,
            selective replication or cheap and easy to derive forward recoveries.
            Also, we will describe how resilience techniques exploiting the task
            parallel concept, which are typically deployed at the shared memory
            level, can be combined with fault tolerant approaches for MPI codes to
            reduce their overheads and increase their effectiveness.
          </div>
        </dd>

        <dt>09:45</dt>
        <dd>
          <strong>Break</strong>
        </dd>

        <dt>10:00</dt>
        <dd>
          <a class="abstract-btn" role="button"
             href="#abstract-d1-1000-vivien" data-toggle="collapse"
             aria-expanded="false" aria-controls="abstract-d1-1100-vivien">
            <i class="fa fa-fw fa-paragraph"></i>
          </a>
          <strong>{% talk_label %} ABFT techniques</strong><br />
          <small>{% person vivien_f %}</small>
          <div class="abstract collapse" id="abstract-d1-1000-vivien">
            This talk will describe ABFT (Algorithm-based Fault-Tolerance) techniques.
            ABFT is a forward-recovery method: the application can continue its progress without rollback after a failure, owing to redundant information computed and stored during execution. 
            ABFT essentially applies to dense and sparse linear algebra kernels.
            We will give several examples and applications.
          </div>
        </dd>

        <dt>11:00</dt>
        <dd>
          <a class="abstract-btn" role="button"
             href="#abstract-d1-1100-hori" data-toggle="collapse"
             aria-expanded="false" aria-controls="abstract-d1-1100-hori">
            <i class="fa fa-fw fa-paragraph"></i>
          </a>
          <strong>{% talk_label %} Robustness of Interconnection Networks</strong><br />
          <small>{% person hori_a %}</small>
          <div class="abstract collapse" id="abstract-d1-1100-hori">
            Fundamental characteristics of interconnect networks used and proposed for high performance computing will be introduced and some insights from the viewpoint of failure and recovery will be presented.
          </div>
        </dd>

        <dt>12:00</dt>
        <dd>
          <strong>Lunch</strong>
        </dd>

        <dt>13:30</dt>
        <dd>
          <a class="abstract-btn" role="button"
             href="#abstract-d1-1330-gomez" data-toggle="collapse"
             aria-expanded="false" aria-controls="abstract-d1-1330-gomez">
            <i class="fa fa-fw fa-paragraph"></i>
          </a>
          <strong>{% handson_label %} Efficient Multilevel Checkpointing with FTI for Large Scale Systems</strong><br />
          <small>{% person gomez_l %}</small>
          <div class="abstract collapse" id="abstract-d1-1330-gomez">
            Large scale supercomputers experience several failures per
            day. Fault tolerance and in particular, scalable multilevel
            checkpointing, are critical for the efficiency of high performance
            system. In this talk, we focus on how to guarantee high reliability for
            scientific applications running in large infrastructures. In particular,
            we cover all the technical content necessary to implement scalable
            multilevel checkpointing in large supercomputers. This course will
            present the internals of the FTI library, to demonstrate how multilevel
            checkpointing is implemented today. This includes code analysis and
            execution traces to help the attendees grasp the fundamental parts of
            this technique. In addition, we will have hands-on examples that the
            attendees can analyse in their own laptops, so that they learn how to
            use FTI in practice, and lately transfer that knowledge to their
            production runs.  By the end of the talk, the attendees will be able to
            implement multilevel checkpointing in their production codes running in
            large scale platforms.
          </div>
        </dd>

        <dt>15:00</dt>
        <dd>
          <strong>Break</strong>
        </dd>

        <dt>15:15</dt>
        <dd>
          <a class="abstract-btn" role="button"
             href="#abstract-d1-1515-calhoun" data-toggle="collapse"
             aria-expanded="false" aria-controls="abstract-d1-1515-calhoun">
            <i class="fa fa-fw fa-paragraph"></i>
          </a>
          <strong>{% handson_label %} Overview of Fault Injection Techniques for HPC</strong><br />
          <small>{% person calhoun_j %}</small>
          <div class="abstract collapse" id="abstract-d1-1515-calhoun">
            In this session, we will overview several methods for HPC fault
            injection covering both fail-stop and fail-silent faults. In particular,
            we will have a hand on with the fault injector FlipIt. FlipIt is a
            compiler based silent error injector that allows a high degree of user
            customization when injecting faults. In addition, we demonstrate
            FlipItâ€™s analysis tool to greatly simplify visualization of fault
            injection results.
          </div>
        </dd>

        <dt>16:45</dt>
        <dd>
          <strong>Close-up</strong>
        </dd>

        <dt>17:00</dt>
        <dd>
          <strong>End of Day 2</strong>
        </dd>
      </dl>
    </div>
  </div>
</div>
 
